generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum UserType {
  ADMIN
  CLIENT
}

enum Role {
  OWNER
  ADMIN
  EDITOR
  VIEWER
}

enum PipelineType {
  CANCER
  GERMLINE
  BACTERIA
}

enum InputSource {
  SOMATIC
  GERMINAL
  LIQUID_BIOPSY
  CLINICAL
}

enum SequenceType {
  WHOLE_GENOME
  WHOLE_EXOME
  GENOMIC_PANEL
}

enum FileType {
  FASTQ
  BAM
  VCF
  MAF
  CSV
  PDF
}

enum FileRole {
  INPUT
  OUTPUT
  INTERMEDIATE
  FINAL_REPORT
}

enum RunStatus {
  RUNNING
  DONE
  FAILED
  PENDING
}

enum AccessType {
  VIEW
  EDIT
  ADMIN
}

enum LicenseType {
  INDIVIDUAL
  SMALL_TEAM
  ORGANIZATION
}

enum LicenseScope {
  USER
  ORGANIZATION
}

enum TagType {
  SAMPLE
  CATEGORY
  FILETYPE
  DISEASE
  CUSTOM
  ANALYSIS_STAGE
  QUALITY_FLAG
  PRIORITY
}

// Licencias
model License {
  id            String       @id @default(cuid())
  licenseType   LicenseType
  licenseScope  LicenseScope
  maxUsers      Int
  assignedUsers Int          @default(0)
  startDate     DateTime
  endDate       DateTime
  isActive      Boolean      @default(true)

  user   User?   @relation(fields: [userId], references: [id])
  userId String? @unique

  organization   Organization? @relation(fields: [organizationId], references: [id])
  organizationId String?       @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Organización
model Organization {
  id         String      @id @default(cuid())
  name       String
  users      User[]
  workspaces Workspace[]
  license    License?
}

// Usuario
model User {
  id                String            @id @default(cuid())
  email             String            @unique
  name              String?
  encryptedPassword String
  userType          UserType          @default(CLIENT)
  organizationId    String
  organization      Organization      @relation(fields: [organizationId], references: [id])
  groupId           String?
  group             Group?            @relation(fields: [groupId], references: [id])
  workspacesOwned   Workspace[]       @relation("OwnedWorkspaces")
  workspaceMembers  WorkspaceMember[]
  sharedProjects    ProjectShare[]
  ownedProjects     Project[]
  license           License?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
}

// Grupos con roles
model Group {
  id    String @id @default(cuid())
  name  String
  role  Role
  users User[]
}

// Workspace
model Workspace {
  id             String            @id @default(cuid())
  name           String
  pipelineType   PipelineType
  organizationId String?
  organization   Organization?     @relation(fields: [organizationId], references: [id])
  ownerId        String
  owner          User              @relation("OwnedWorkspaces", fields: [ownerId], references: [id])
  projects       Project[]
  members        WorkspaceMember[]
}

// Relación usuario - workspace (acceso)
model WorkspaceMember {
  id          String @id @default(cuid())
  userId      String
  workspaceId String
  role        Role

  user      User      @relation(fields: [userId], references: [id])
  workspace Workspace @relation(fields: [workspaceId], references: [id])

  @@unique([userId, workspaceId]) // Evita duplicados
}

// Proyecto
model Project {
  id          String         @id @default(cuid())
  name        String
  description String?
  workspaceId String
  workspace   Workspace      @relation(fields: [workspaceId], references: [id])
  ownerId     String
  owner       User           @relation(fields: [ownerId], references: [id])
  sharedWith  ProjectShare[]
  inputFiles  GenomicFile[]
  executions  PipelineRun[]
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @default(now())
}

// Compartir proyecto con otros usuarios
model ProjectShare {
  id        String     @id @default(cuid())
  userId    String
  projectId String
  access    AccessType

  user    User    @relation(fields: [userId], references: [id])
  project Project @relation(fields: [projectId], references: [id])

  @@unique([userId, projectId]) // Evita compartir duplicado
}

// Archivos genómicos
model GenomicFile {
  id         String   @id @default(cuid())
  filename   String
  path       String
  fileType   FileType
  fileRole   FileRole
  project    Project  @relation(fields: [projectId], references: [id])
  projectId  String
  sampleId   Int?
  sample     Sample?  @relation(fields: [sampleId], references: [id])
  uploadedAt DateTime @default(now())

  pipelineRun   PipelineRun? @relation("PipelineRunLink", fields: [pipelineRunId], references: [id])
  pipelineRunId String?

  inputForRun   PipelineRun? @relation("InputFiles", fields: [inputForRunId], references: [id])
  inputForRunId String?

  outputOfRun   PipelineRun? @relation("OutputFiles", fields: [outputOfRunId], references: [id])
  outputOfRunId String?

  documentTags DocumentTag[]
}

model PipelineRun {
  id          String        @id @default(cuid())
  startedAt   DateTime
  endedAt     DateTime?
  status      RunStatus
  workflow    String
  inputFiles  GenomicFile[] @relation("InputFiles")
  outputFiles GenomicFile[] @relation("OutputFiles")
  project     Project       @relation(fields: [projectId], references: [id])
  projectId   String

  pipelineFiles GenomicFile[] @relation("PipelineRunLink")
}

// Datos genómicos
model Sample {
  id             Int           @id @default(autoincrement())
  sampleName     String
  reportDate     DateTime
  sampleType     InputSource
  sequencingType SequenceType
  disease        String
  folioNumber    Int
  genomicFiles   GenomicFile[] // Relación inversa
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
}

// Sistema de tags
model Tag {
  id        String        @id @default(cuid())
  name      String
  type      TagType
  documents DocumentTag[]
}

model DocumentTag {
  id     String      @id @default(cuid())
  file   GenomicFile @relation(fields: [fileId], references: [id])
  fileId String
  tag    Tag         @relation(fields: [tagId], references: [id])
  tagId  String
}

/**
 * tips
 * // DOCUMENTO => ID TAGS (AUTOINCREMENTAL UNICO 1 !== ID)
 * // OTRA TABLA QUE HAGA ASOCIAC CON SAMPLE
 * // EDAD SEXO ENFERMEDAD
 * limites asociados (rol de propietario, revisa licencia)
 */

 // añadir nuevo lenguaje

/**
 * Un User pertenece a una Organization (1:N), puede tener una License directa (1:1) o usar la de su organización (1:1). El usuario crea o pertenece a uno o más Workspaces (1:N mediante Workspace.ownerId y WorkspaceMember) donde puede tener distintos Roles. Cada Workspace agrupa varios Projects (1:N), de los cuales el usuario puede ser owner o estar compartido vía ProjectShare (M:N con AccessType).
 * Dentro de un Project, el usuario sube GenomicFiles (1:N), que pueden estar vinculados a un Sample (opcional, 1:N), y usar esos archivos como input/output de PipelineRun (N:M). Los resultados y archivos pueden etiquetarse mediante la relación DocumentTag con Tag (M:N).
 * cada Sample puede tener varios Genes (1:N), cada Gene varias Variants (1:N), y asociarse a múltiples ActivePrinciples mediante la tabla puente ActivePrincipleOnGene (M:N).
 * En conjunto, el recorrido fluye desde User → Workspace → Project → GenomicFile → PipelineRun/Sample → Gene → Variant/ActivePrinciple, permitiendo acceso, colaboración y trazabilidad controlada por roles, licencias y relaciones compartidas.
 */

/**
 * ¿cómo trackear archivos de diferentes ejecuciones?
 * R:
 * ¿la licencia debería estar relacionada a los usuarios/grupos/depto u organización?
 * R:
 * ¿Cuáles serán los archivos de entrada y salida para cada pipeline?
 * R:
 * ¿Usaremos una base única para todos los clientes o una por organización?
 * R:
 * ¿La licencia debe limitar solo usuarios o también proyectos/espacios de trabajo?
 * R:
 * ¿Queremos controlar el número de proyectos activos por tipo de licencia?
 * R:
 * ¿Queremos permitir que usuarios sin organización trabajen colaborativamente (por invitación directa a proyectos)?
 * R:
 * ¿Cada proyecto tendrá solo un Clinical Data (inputfiles) o podría necesitar varios (por fases, versiones)?
 * R:
 * ¿Los roles actuales (OWNER, ADMIN, EDITOR, VIEWER) cubren todos los escenarios o falta alguno?
 * R:
 * ¿Cada proyecto tendrá un solo pipeline o podría haber múltiples ejecuciones paralelas?
 * R:
 * Si un paso falla, ¿qué nivel de detalle queremos mostrar al usuario?
 * R:
 * ¿Mostrar logs técnicos?
 * R:
 * ¿Un mensaje básico de error?
 * R:
 * ¿Permitir descarga de logs?
 * R:
 * ¿Queremos permitir tags definidas sólo globalmente o también personalizadas por la organización?
 * R:
 * ¿Queremos limitar el tamaño máximo de archivos subidos o el almacenamiento total por usuario/organización/licencia?
 * R:
 */
